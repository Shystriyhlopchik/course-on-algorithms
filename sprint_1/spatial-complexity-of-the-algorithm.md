# Пространственная сложность алгоритма

Эффективность программы можно оценить по тому, как она расходует разные типы ресурсов компьютера. Основные из них — процессорное время и оперативная память. А ещё есть пропускная способность сетевых подключений, время работы жёсткого диска и некоторые другие.

### Что такое пространственная сложность алгоритма

Мы уже поговорили про понятие вычислительной (или временнóй) сложности, которое определяет, насколько эффективно алгоритм использует процессорное время. Если алгоритм имеет слишком высокую вычислительную сложность, пользователь будет ждать результатов работы программы очень долго.

Ещё одна важная характеристика — объём оперативной памяти. Программы, которым не хватает памяти, будут зависать и мешать работе других программ. А во многих случаях и вовсе не смогут доделать свою работу до конца.

```no-highlight
Если программе не хватает оперативной памяти, она пытается использовать файл подкачки, 
или swap-раздел (от англ. swap — «подкачивать»), расположенный во внешней памяти (на жёстком 
диске или на SSD-диске). При недостатке оперативной памяти программа начинает 
перекладывать данные из небольшой, но быстрой оперативной памяти на большой, но
медленный диск. И по мере необходимости возвращать требуемые данные с диска в память.
Это очень медленный процесс. Именно из-за него программы, вышедшие за пределы оперативной 
памяти, начинают тратить много процессорного времени и зависать, даже если у них небольшая 
временна́я сложность. И, что ещё хуже, они могут вытеснять из памяти другие программы, 
которые в таком случае тоже зависают. Если запущенные на компьютере программы заняли 
не только всю оперативную память, но и файл подкачки, то какая-то из программ завершится 
аварийно.
```

Каждый объект в программе занимает некоторый объём памяти, а для хранения всех объектов может потребоваться немало пространства. Особенное внимание, конечно, следует уделять массивам, строкам и прочим контейнерам, ведь их размер не строго фиксирован и зависит от входных данных. 

Пространственной сложностью алгоритма называется зависимость объёма потребляемой памяти от входных данных. Как и в случае с временной сложностью, нас в первую очередь интересует не точный объём памяти, а асимптотика, то есть скорость роста без учёта констант и коэффициентов.

Программа, которая в какой-то момент своей работы хранит все данные, переданные ей на вход, занимает _O(n)_, или линейно зависящее от объёма входных данных
_n_ количество памяти.

Если алгоритм принимает на вход _n_ объектов, а потом создаёт, например, таблицу попарных расстояний между объектами, то такая программа займёт уже _O(n<sup>2</sup>)_ памяти — квадратичный объём.

### Взаимосвязь пространственной и временной сложности алгоритма

Каждое живое существо на Земле (от бактерии до человека) закодировано набором молекул ДНК. Каждая такая молекула является сочетанием четырёх более простых молекул — азотистых оснований, которые называются:

* аденин (A),
* тимин (Т),
* гуанин (G)
* и цитозин (C).

Спираль ДНК состоит из двух соединённых цепочек этих оснований. Соединяются цепочки водородными связями между основаниями и только попарно: аденин всегда только с тимином (A-T связь), а цитозин — только с гуанином (C-G связь). При этом аденин с тимином соединяются двойной водородной связью, а цитозин с гуанином — тройной. Поэтому, чем больше в спирали C-G связей, тем сложнее разорвать спираль и тем прочнее будет молекула ДНК.

В компьютере последовательность генома записана как очень длинная строка, состоящая из букв A, C, G, T: AGTAGATCAACTGTGTCGTGAGAG... и так далее. Вторую цепь не записывают, ведь напротив A всегда стоит T, а  напротив C — G.

Алла и Рита хотят проверить разные участки ДНК на прочность. Чтобы узнать, насколько какой-нибудь участок ДНК прочный, нужно подсчитать число букв C и G на нём: чем их больше, тем участок генома прочнее.

Подруги договорились, что Алла будет задавать границы исследуемого участка, а Рита — подсчитывать число нужных букв.

![](img/Image6.png)

Сначала Рита решила действовать так: она завела счётчик и стала перебирать все буквы в полуинтервале, увеличивая счётчик, если встретилась C или G.

```js
let cg_count = 0;
for (let position = left; position < right; position++) {
    if (sequence[position] === 'C' || sequence[position] === 'G') {
        cg_count++;
    }
}
console.log(cg_count);
```

На то, чтобы подсчитать количество нужных букв, она потратила _O(n)_ времени, где
_n_ — длина полуинтервала. Но вспомогательная память ей понадобилось всего для трёх переменных: позиции в тексте, счётчика, а также для объекта range. Эти три переменные занимают фиксированный объём памяти, не зависящий от длины интервала, поэтому можно сказать, что Рите потребовалось
_O(1)_ дополнительной памяти.

Почему дополнительной? Потому что последовательность генома в любом случае придётся хранить в памяти. А то, сколько программе потребуется памяти сверх этого, зависит от выбранного алгоритма — это и есть дополнительная память.

Потом Рита устала пересчитывать одни и те же буквы и придумала новый способ решения. Напротив каждой позиции она написала число — сколько раз нужная буква (C или G) встретилась от начала строки и до текущей позиции (не включая её саму) — это называется «накопительная сумма» (англ. cumulative sum).

```
C C A T G A T C
0 1 2 2 2 3 3 3 4
```

Чтобы посчитать количество CG-букв на каком-то полуинтервале, достаточно вычесть из накопительной суммы на правом конце (вернее, на позиции ```right```) аналогичную сумму на левом конце. 

```python
cumulative_sums = [0]
cg_count = 0
for position in range(0, len(sequence)):
    if (sequence[position] == 'C') or (sequence[position] == 'G'):
        cg_count += 1
    cumulative_sums.append(cg_count)

print(cumulative_sums[right] - cumulative_sums[left])
```

Теперь Рита может очень быстро отвечать на вопросы Аллы о прочности конкретных участков генома. Ей потребовалось один раз провести предподсчёт сумм за
_O(n)_, а для нахождения суммы на интервале достаточно выполнить простое вычитание, что занимает константное время, то есть _O(1)_.

А вот памяти Рита потратила _O(n)_: она напротив каждой буквы написала по числу.

Рассмотренная в примере ситуация типична: мы сохранили вспомогательную информацию, чтобы тратить меньше времени, то есть «обменяли» память на скорость. При решении задач вам порой придётся делать непростой выбор: либо сохранять больше данных, чтобы уменьшить объём вычислений; либо считать медленнее, но сэкономить память.

Следует помнить о том, что слишком большой расход памяти может привести к тому, что программа завершится с ошибкой. Или её производительность ухудшится из-за использования файла подкачки.

```
Во многих случаях не требуется даже изменять алгоритм, достаточно лишь сохранять 
результаты промежуточных вычислений. Эта техника называется «кеширование». В первую 
очередь следует кешировать результаты, которые долго вычисляются и часто используются.
```

Теперь вы знаете, что такое пространственная сложность алгоритма и как её можно оценить. Решая задачи, старайтесь заранее рассчитывать, сколько памяти будет занимать ваша программа. Это позволит вам оценить работоспособность программы ещё до того, как вы напишете первую строчку её кода.